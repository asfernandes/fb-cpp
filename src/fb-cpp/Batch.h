/*
 * MIT License
 *
 * Copyright (c) 2026 F.D.Castel
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef FBCPP_BATCH_H
#define FBCPP_BATCH_H

#include "fb-api.h"
#include "Blob.h"
#include "Descriptor.h"
#include "SmartPtrs.h"
#include "Exception.h"
#include <cassert>
#include <cstddef>
#include <cstdint>
#include <optional>
#include <span>
#include <string_view>
#include <vector>


///
/// fb-cpp namespace.
///
namespace fbcpp
{
	class Attachment;
	class Client;
	class Statement;
	class Transaction;

	///
	/// Selects the blob handling policy for a Batch.
	///
	enum class BlobPolicy : unsigned char
	{
		///
		/// Blobs are not allowed in the batch.
		///
		NONE = fb::IBatch::BLOB_NONE,

		///
		/// Batch-local blob IDs are generated by the Firebird engine.
		///
		ID_ENGINE = fb::IBatch::BLOB_ID_ENGINE,

		///
		/// Batch-local blob IDs are generated by the caller.
		///
		ID_USER = fb::IBatch::BLOB_ID_USER,

		///
		/// Blobs are sent inline as a stream.
		///
		STREAM = fb::IBatch::BLOB_STREAM,
	};

	///
	/// Configuration options for creating a Batch.
	///
	/// These options map to `IXpbBuilder` parameters for the `IBatch` interface.
	/// All setters return `*this` for fluent configuration.
	///
	class BatchOptions final
	{
	public:
		///
		/// Returns whether multiple errors are collected per execution.
		///
		bool getMultiError() const
		{
			return multiError;
		}

		///
		/// Enables or disables collection of multiple errors per execution.
		///
		BatchOptions& setMultiError(bool value)
		{
			multiError = value;
			return *this;
		}

		///
		/// Returns whether per-message affected row counts are reported.
		///
		bool getRecordCounts() const
		{
			return recordCounts;
		}

		///
		/// Enables or disables per-message affected row counts.
		///
		BatchOptions& setRecordCounts(bool value)
		{
			recordCounts = value;
			return *this;
		}

		///
		/// Returns the batch buffer size in bytes, or nullopt for the server default.
		///
		std::optional<unsigned> getBufferBytesSize() const
		{
			return bufferBytesSize;
		}

		///
		/// Sets the batch buffer size in bytes.
		///
		BatchOptions& setBufferBytesSize(unsigned value)
		{
			bufferBytesSize = value;
			return *this;
		}

		///
		/// Returns the blob handling policy.
		///
		BlobPolicy getBlobPolicy() const
		{
			return blobPolicy;
		}

		///
		/// Sets the blob handling policy.
		///
		BatchOptions& setBlobPolicy(BlobPolicy value)
		{
			blobPolicy = value;
			return *this;
		}

		///
		/// Returns the maximum number of detailed error statuses to collect.
		///
		unsigned getDetailedErrors() const
		{
			return detailedErrors;
		}

		///
		/// Sets the maximum number of detailed error statuses to collect.
		///
		BatchOptions& setDetailedErrors(unsigned value)
		{
			detailedErrors = value;
			return *this;
		}

	private:
		bool multiError = false;
		bool recordCounts = false;
		std::optional<unsigned> bufferBytesSize;
		BlobPolicy blobPolicy = BlobPolicy::NONE;
		unsigned detailedErrors = 64;
	};

	///
	/// Wraps `IBatchCompletionState` to provide RAII-safe access to batch execution results.
	///
	/// This is a move-only type. The underlying Firebird handle is disposed in the destructor.
	///
	class BatchCompletionState final
	{
	public:
		///
		/// Per-message state value indicating the message failed to execute.
		///
		static constexpr int EXECUTE_FAILED = fb::IBatchCompletionState::EXECUTE_FAILED;

		///
		/// Per-message state value indicating success with no row-count information.
		///
		static constexpr int SUCCESS_NO_INFO = fb::IBatchCompletionState::SUCCESS_NO_INFO;

		///
		/// Constructs a BatchCompletionState from a Firebird completion state handle.
		///
		explicit BatchCompletionState(Client& client, FbUniquePtr<fb::IBatchCompletionState> handle) noexcept;

		///
		/// Transfers ownership of another completion state into this one.
		///
		BatchCompletionState(BatchCompletionState&& o) noexcept;

		///
		/// Move assignment is not supported.
		///
		BatchCompletionState& operator=(BatchCompletionState&&) = delete;

		///
		/// Copy construction is not supported.
		///
		BatchCompletionState(const BatchCompletionState&) = delete;

		///
		/// Copy assignment is not supported.
		///
		BatchCompletionState& operator=(const BatchCompletionState&) = delete;

	public:
		///
		/// Returns the number of messages processed.
		///
		unsigned getSize();

		///
		/// Returns the per-message result at the given position.
		///
		/// The value is either the number of affected rows, `EXECUTE_FAILED`, or `SUCCESS_NO_INFO`.
		///
		int getState(unsigned pos);

		///
		/// Finds the next error at or after the given position.
		///
		/// Returns `std::nullopt` when there are no more errors.
		///
		std::optional<unsigned> findError(unsigned pos);

		///
		/// Returns the detailed error status vector for the given position.
		///
		/// The returned vector has the same format as `IStatus::getErrors()`.
		///
		std::vector<std::intptr_t> getStatus(unsigned pos);

	private:
		Client* client;
		FbUniquePtr<fb::IStatus> status;
		impl::StatusWrapper statusWrapper;
		FbUniquePtr<fb::IBatchCompletionState> handle;
	};

	///
	/// @brief Wraps the Firebird `IBatch` interface for bulk DML operations.
	///
	/// A Batch collects multiple parameter sets ("messages") and sends them to
	/// the server in a single round-trip for execution.  This maps directly to
	/// ODBC's "array of parameter values" feature (`SQL_ATTR_PARAMSET_SIZE > 1`)
	/// and is the primary performance path for ETL workloads against Firebird 4.0+.
	///
	/// Two creation paths are supported:
	/// - From a **prepared `Statement`** — uses `IStatement::createBatch()`.
	///   The `Statement` must remain valid for the lifetime of the `Batch`.
	///   The convenience method `addMessage()` copies the Statement's current
	///   input-message buffer into the batch.
	/// - From an **`Attachment` + SQL text** — uses `IAttachment::createBatch()`.
	///   Messages must be added via the raw `add()` method.
	///
	class Batch final
	{
	public:
		///
		/// Creates a Batch from a prepared Statement.
		///
		/// The Statement must remain valid for the lifetime of the Batch.
		///
		explicit Batch(Statement& statement, Transaction& transaction, const BatchOptions& options = {});

		///
		/// Creates a Batch from an Attachment and SQL text.
		///
		explicit Batch(Attachment& attachment, Transaction& transaction, std::string_view sql, unsigned dialect = 3,
			const BatchOptions& options = {});

		///
		/// Transfers ownership of another Batch into this one.
		///
		Batch(Batch&& o) noexcept;

		///
		/// Move assignment is not supported.
		///
		Batch& operator=(Batch&&) = delete;

		///
		/// Copy construction is not supported.
		///
		Batch(const Batch&) = delete;

		///
		/// Copy assignment is not supported.
		///
		Batch& operator=(const Batch&) = delete;

		///
		/// Closes the batch handle if still valid.
		///
		~Batch() noexcept
		{
			if (isValid())
			{
				try
				{
					close();
				}
				catch (...)
				{
					// swallow
				}
			}
		}

	public:
		///
		/// Returns whether the batch handle is valid.
		///
		bool isValid() const noexcept
		{
			return handle != nullptr;
		}

		///
		/// @name Adding messages
		/// @{
		///

		///
		/// Adds one or more raw messages to the batch buffer.
		///
		/// `inBuffer` must contain `count` aligned messages matching the input metadata.
		///
		void add(unsigned count, const void* inBuffer);

		///
		/// Adds the Statement's current input-message buffer as one message.
		///
		/// Requires the Statement-based constructor.
		/// Typical usage:
		/// ```
		/// stmt.setInt32(0, val);
		/// batch.addMessage();
		/// ```
		///
		void addMessage();

		///
		/// @}
		///

		///
		/// @name Blob support
		/// @{
		///

		///
		/// Adds an inline blob and returns its batch-local ID.
		///
		/// Only valid when `BlobPolicy` is `ID_ENGINE` or `ID_USER`.
		///
		BlobId addBlob(std::span<const std::byte> data, const BlobOptions& bpb = {});

		///
		/// Appends more data to the last blob added with `addBlob()`.
		///
		void appendBlobData(std::span<const std::byte> data);

		///
		/// Adds blob data in stream mode (`BlobPolicy::STREAM` only).
		///
		void addBlobStream(std::span<const std::byte> data);

		///
		/// Registers an existing blob (created via the normal `Blob` class) for use
		/// in the batch, and returns its batch-local ID.
		///
		BlobId registerBlob(const BlobId& existingBlob);

		///
		/// Sets the default BPB (Blob Parameter Block) for blobs in this batch.
		///
		void setDefaultBpb(const BlobOptions& bpb);

		///
		/// Returns the blob alignment requirement for this batch.
		///
		unsigned getBlobAlignment();

		///
		/// @}
		///

		///
		/// @name Execution
		/// @{
		///

		///
		/// Executes all queued messages and returns the completion state.
		///
		BatchCompletionState execute();

		///
		/// Cancels the batch, discarding all queued messages.
		///
		void cancel();

		///
		/// Closes the batch handle and releases resources.
		///
		void close();

		///
		/// Returns the input metadata for this batch.
		///
		FbRef<fb::IMessageMetadata> getInputMetadata();

		///
		/// Returns cached input parameter descriptors for this batch.
		///
		const std::vector<Descriptor>& getInputDescriptors();

		///
		/// @}
		///

	private:
		std::vector<std::uint8_t> buildParametersBlock(Client& client, const BatchOptions& options);
		std::vector<std::uint8_t> prepareBpb(Client& client, const BlobOptions& bpb);
		void buildInputDescriptors();

	private:
		Client* client;
		Transaction* transaction;
		Statement* statement = nullptr;
		FbUniquePtr<fb::IStatus> status;
		impl::StatusWrapper statusWrapper;
		FbRef<fb::IBatch> handle;
		std::vector<Descriptor> inputDescriptors;
	};
}  // namespace fbcpp


#endif  // FBCPP_BATCH_H
